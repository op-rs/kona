import { Callout } from 'vocs/components'

# Custom Derivation Pipeline with New Stage

Custom pipeline stages enable developers to extend Kona's derivation pipeline with specialized logic for monitoring, validation, or data transformation. By implementing a few key traits, you can insert custom stages that intercept and process data flowing through the pipeline.

## Core Concepts

The derivation pipeline uses a stage-based architecture where each stage wraps the previous one:

```
L1Traversal → L1Retrieval → FrameQueue → ChannelProvider → 
ChannelReader → BatchStream → BatchProvider → AttributesQueue
```

### Key Traits

Every pipeline stage must implement these traits:

```rust
use kona_derive::{
    NextAttributes, OriginProvider, SignalReceiver, OriginAdvancer,
    PipelineResult, Signal, OpAttributesWithParent
};
use kona_protocol::{BlockInfo, L2BlockInfo};

// Provides next attributes for block building
trait NextAttributes {
    async fn next_attributes(&mut self, parent: L2BlockInfo) 
        -> PipelineResult<OpAttributesWithParent>;
}

// Provides current L1 origin
trait OriginProvider {
    fn origin(&self) -> Option<BlockInfo>;
}

// Handles pipeline signals (reset, activation)
trait SignalReceiver {
    async fn signal(&mut self, signal: Signal) -> PipelineResult<()>;
}

// Advances to next L1 origin
trait OriginAdvancer {
    async fn advance_origin(&mut self) -> PipelineResult<()>;
}
```

## Custom Stage Example

Here's a logging stage that wraps another stage to track metrics:

```rust
use kona_derive::{
    NextAttributes, OriginProvider, SignalReceiver, OriginAdvancer,
    PipelineResult, Signal, OpAttributesWithParent
};
use kona_protocol::{BlockInfo, L2BlockInfo};
use async_trait::async_trait;
use std::time::Instant;

#[derive(Debug)]
pub struct LoggingStage<S> {
    inner: S,
    attributes_count: u64,
    last_origin: Option<BlockInfo>,
}

impl<S> LoggingStage<S> {
    pub fn new(inner: S) -> Self {
        Self {
            inner,
            attributes_count: 0,
            last_origin: None,
        }
    }
}

#[async_trait]
impl<S> NextAttributes for LoggingStage<S>
where
    S: NextAttributes + Send + Sync,
{
    async fn next_attributes(
        &mut self, 
        parent: L2BlockInfo
    ) -> PipelineResult<OpAttributesWithParent> {
        let start = Instant::now();
        
        // Delegate to inner stage
        let attributes = self.inner.next_attributes(parent).await?;
        
        // Track metrics
        self.attributes_count += 1;
        let duration = start.elapsed();
        
        info!(
            target: "pipeline::logging",
            count = self.attributes_count,
            duration_ms = duration.as_millis(),
            parent_hash = ?parent.block_info.hash,
            "Generated attributes"
        );
        
        Ok(attributes)
    }
}

impl<S> OriginProvider for LoggingStage<S>
where
    S: OriginProvider,
{
    fn origin(&self) -> Option<BlockInfo> {
        self.inner.origin()
    }
}

#[async_trait]
impl<S> SignalReceiver for LoggingStage<S>
where
    S: SignalReceiver + Send + Sync,
{
    async fn signal(&mut self, signal: Signal) -> PipelineResult<()> {
        info!(target: "pipeline::logging", ?signal, "Received signal");
        
        // Track origin changes on reset
        if let Signal::Reset(reset) = &signal {
            self.last_origin = Some(reset.l1_origin);
            self.attributes_count = 0; // Reset counter
        }
        
        self.inner.signal(signal).await
    }
}

#[async_trait]
impl<S> OriginAdvancer for LoggingStage<S>
where
    S: OriginAdvancer + Send + Sync,
{
    async fn advance_origin(&mut self) -> PipelineResult<()> {
        let prev_origin = self.inner.origin();
        self.inner.advance_origin().await?;
        let new_origin = self.inner.origin();
        
        if prev_origin != new_origin {
            info!(
                target: "pipeline::logging",
                prev = ?prev_origin,
                new = ?new_origin,
                "Advanced origin"
            );
        }
        
        Ok(())
    }
}
```

<Callout type="info">
  Custom stages can implement additional logic like validation, caching, or rate limiting.
  The key is properly delegating to the inner stage while adding your custom behavior.
</Callout>

## Integration

Build a pipeline with your custom stage:

```rust
use kona_derive::{PipelineBuilder, DerivationPipeline};
use kona_node::{StatefulAttributesBuilder};
use alloc::sync::Arc;

async fn build_custom_pipeline(
    rollup_config: Arc<RollupConfig>,
    chain_provider: impl ChainProvider,
    l2_chain_provider: impl L2ChainProvider,
    dap_source: impl DataAvailabilityProvider,
    attributes_builder: StatefulAttributesBuilder,
    origin: BlockInfo,
) -> DerivationPipeline<LoggingStage<impl NextAttributes>, impl L2ChainProvider> {
    // Build standard pipeline
    let standard_pipeline = PipelineBuilder::new()
        .rollup_config(rollup_config.clone())
        .origin(origin)
        .chain_provider(chain_provider)
        .l2_chain_provider(l2_chain_provider.clone())
        .dap_source(dap_source)
        .builder(attributes_builder)
        .build_polled();
    
    // Wrap attributes stage with logging
    let logging_stage = LoggingStage::new(standard_pipeline.attributes);
    
    // Create new pipeline with custom stage
    DerivationPipeline::new(
        logging_stage,
        rollup_config,
        l2_chain_provider,
    )
}
```

## Testing Custom Stages

Test your custom stage in isolation:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use kona_derive::test_utils::TestNextAttributes;
    
    #[tokio::test]
    async fn test_logging_stage() {
        let mock_inner = TestNextAttributes::new();
        let mut stage = LoggingStage::new(mock_inner);
        
        // Test attributes generation
        let parent = L2BlockInfo::default();
        let result = stage.next_attributes(parent).await;
        assert!(result.is_ok());
        assert_eq!(stage.attributes_count, 1);
        
        // Test signal handling
        let signal = Signal::Reset(Default::default());
        stage.signal(signal).await.unwrap();
        assert_eq!(stage.attributes_count, 0);
    }
}
```

## Related Resources

- [kona-derive](https://github.com/op-rs/kona/tree/main/crates/protocol/derive) - Core derivation pipeline
- [Pipeline Traits](https://github.com/op-rs/kona/tree/main/crates/protocol/derive/src/traits) - Trait definitions
- [Stage Examples](https://github.com/op-rs/kona/tree/main/crates/protocol/derive/src/stages) - Built-in stages
- [OP Stack Derivation Spec](https://specs.optimism.io/protocol/derivation.html) - Protocol specification